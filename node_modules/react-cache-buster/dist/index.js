function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));
var compareVersions = require('compare-versions');

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var CacheBusterContext = React.createContext({
  checkCacheStatus: function checkCacheStatus() {}
});

function CacheBuster(_ref) {
  var _ref$children = _ref.children,
      children = _ref$children === void 0 ? null : _ref$children,
      currentVersion = _ref.currentVersion,
      _ref$isEnabled = _ref.isEnabled,
      isEnabled = _ref$isEnabled === void 0 ? false : _ref$isEnabled,
      _ref$isVerboseMode = _ref.isVerboseMode,
      isVerboseMode = _ref$isVerboseMode === void 0 ? false : _ref$isVerboseMode,
      _ref$loadingComponent = _ref.loadingComponent,
      loadingComponent = _ref$loadingComponent === void 0 ? null : _ref$loadingComponent,
      _ref$metaFileDirector = _ref.metaFileDirectory,
      metaFileDirectory = _ref$metaFileDirector === void 0 ? null : _ref$metaFileDirector,
      _ref$reloadOnDowngrad = _ref.reloadOnDowngrade,
      reloadOnDowngrade = _ref$reloadOnDowngrad === void 0 ? false : _ref$reloadOnDowngrad,
      onCacheClear = _ref.onCacheClear;

  var _useState = React.useState({
    loading: true,
    isLatestVersion: false
  }),
      cacheStatus = _useState[0],
      setCacheStatus = _useState[1];

  var log = function log(message, isError) {
    isVerboseMode && (isError ? console.error(message) : console.log(message));
  };

  React.useEffect(function () {
    isEnabled ? checkCacheStatus() : log('React Cache Buster is disabled.');
  }, []);

  var getMetaFileDirectory = function getMetaFileDirectory() {
    return !metaFileDirectory || metaFileDirectory === '.' ? '' : metaFileDirectory;
  };

  var checkCacheStatus = React.useCallback(function () {
    try {
      var _temp2 = _catch(function () {
        return Promise.resolve(fetch(getMetaFileDirectory() + "/meta.json")).then(function (res) {
          return Promise.resolve(res.json()).then(function (_ref2) {
            var metaVersion = _ref2.version;
            var shouldForceRefresh = isThereNewVersion(metaVersion, currentVersion);

            if (shouldForceRefresh) {
              log("There is a new version (v" + metaVersion + "). Should force refresh.");
              setCacheStatus({
                loading: false,
                isLatestVersion: false
              });
            } else {
              log('There is no new version. No cache refresh needed.');
              setCacheStatus({
                loading: false,
                isLatestVersion: true
              });
            }
          });
        });
      }, function (error) {
        log('An error occurred while checking cache status.', true);
        log(error, true);
        !isVerboseMode && setCacheStatus({
          loading: false,
          isLatestVersion: true
        });
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }, [currentVersion, isVerboseMode, metaFileDirectory]);

  var isThereNewVersion = function isThereNewVersion(metaVersion, currentVersion) {
    if (reloadOnDowngrade) {
      return !compareVersions.compare(metaVersion, currentVersion, '=');
    }

    return compareVersions.compare(metaVersion, currentVersion, '>');
  };

  var refreshCacheAndReload = function refreshCacheAndReload() {
    try {
      return Promise.resolve(_catch(function () {
        var _temp3 = function () {
          var _window;

          if ((_window = window) !== null && _window !== void 0 && _window.caches) {
            var _window2 = window,
                caches = _window2.caches;
            return Promise.resolve(caches.keys()).then(function (cacheNames) {
              var cacheDeletionPromises = cacheNames.map(function (n) {
                return caches["delete"](n);
              });
              return Promise.resolve(Promise.all(cacheDeletionPromises)).then(function () {
                log('The cache has been deleted.');
                window.location.reload(true);
              });
            });
          }
        }();

        if (_temp3 && _temp3.then) return _temp3.then(function () {});
      }, function (error) {
        log('An error occurred while deleting the cache.', true);
        log(error, true);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  if (!isEnabled) {
    return children;
  } else {
    if (cacheStatus.loading) {
      return loadingComponent;
    }

    if (!cacheStatus.loading && !cacheStatus.isLatestVersion) {
      if (onCacheClear) {
        onCacheClear(refreshCacheAndReload);
      } else {
        refreshCacheAndReload();
      }

      return null;
    }

    return React__default.createElement(CacheBusterContext.Provider, {
      value: {
        checkCacheStatus: checkCacheStatus
      }
    }, children);
  }
}

CacheBuster.propTypes = {
  children: PropTypes.element.isRequired,
  currentVersion: PropTypes.string.isRequired,
  isEnabled: PropTypes.bool.isRequired,
  isVerboseMode: PropTypes.bool,
  loadingComponent: PropTypes.element,
  metaFileDirectory: PropTypes.string,
  onCacheClear: PropTypes.func
};

var useCacheBuster = function useCacheBuster() {
  var context = React.useContext(CacheBusterContext);

  if (context === undefined || context === null) {
    throw new Error('useCacheBuster must be used within a CacheBuster component.');
  }

  return context;
};

exports.default = CacheBuster;
exports.useCacheBuster = useCacheBuster;
